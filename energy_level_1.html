<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Born-Haber Cycle - Part 1</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 100%;
            margin: 0 auto;
            padding: 10px;
            background-color: #f5f5f5;
            box-sizing: border-box;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            font-size: 1.6rem;
            margin: 10px 0;
        }
        .instructions {
            background-color: #eaf2f8;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            border-left: 5px solid #3498db;
            text-align: center;
        }
        .instructions p {
            margin: 5px 0;
            font-size: 0.9rem;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 20px;
            width: 100%;
        }
        .source-heading {
            margin-bottom: 10px;
            color: #2c3e50;
            text-align: center;
        }
        .image-source {
            background-color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            min-height: 80px;
        }
        .sequence-area {
            background-color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            position: relative;
            overflow-x: auto;
            max-width: 100%;
            min-height: 450px;
            width: 100%;
            box-sizing: border-box;
        }
        .image-item {
            width: 150px;
            height: 150px;
            margin: 10px;
            cursor: pointer;
            border: 2px solid #3498db;
            border-radius: 5px;
            transition: transform 0.3s;
            position: relative;
            background-color: white;
        }
        .image-item:hover {
            transform: scale(1.05);
        }
        .image-item img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .sequence-box {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 240px;
            margin: 0 auto;
            flex-wrap: nowrap;
            min-width: max-content;
        }
        .drop-zone-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 5px;
        }
        .drop-zone {
            width: 150px;
            height: 150px;
            border: 2px dashed #3498db;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .drop-zone.active {
            background-color: #d4e6f1;
        }
        .drop-zone.filled {
            border-style: solid;
            background-color: #eaf2f8;
            box-shadow: 0 3px 8px rgba(52, 152, 219, 0.3);
        }
        .button-container {
            text-align: center;
            margin-top: 20px;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            margin: 0 5px 10px;
        }
        button:hover {
            background-color: #2980b9;
        }
        #feedback {
            margin: 15px 0;
            padding: 15px;
            border-radius: 5px;
            display: none;
            text-align: center;
        }
        #feedback.success {
            background-color: #d4edda;
            border-left: 5px solid #28a745;
        }
        #feedback.error {
            background-color: #f8d7da;
            border-left: 5px solid #dc3545;
        }
        .connector-arrow {
            font-size: 24px;
            color: #3498db;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 30px;
        }
        .box-header {
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .sequence-box {
                justify-content: flex-start;
                padding-bottom: 10px;
            }
            .drop-zone {
                width: 130px;
                height: 130px;
            }
            .image-item {
                width: 120px;
                height: 120px;
            }
            h1 {
                font-size: 1.5rem;
            }
            .instructions p {
                font-size: 0.9rem;
            }
        }
        
        /* Make sure elements don't shrink too much on very small screens */
        @media (max-width: 400px) {
            .drop-zone {
                min-width: 120px;
                min-height: 120px;
            }
        }
        
        /* Selected image styling */
        .image-item.selected {
            border: 2px solid #e74c3c;
            box-shadow: 0 0 8px rgba(231, 76, 60, 0.6);
        }
        
        .sequence-heading {
            margin-bottom: 10px;
            color: #2c3e50;
            text-align: center;
        }
        
        /* Additional styles for the flowchart layout */
        .flowchart-sequence {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
        }
        
        .main-flow {
            display: flex;
            flex-direction: row;
            align-items: center;
            width: 100%;
            margin: 20px 0;
            justify-content: space-between;
            flex-wrap: nowrap;
            overflow-x: auto;
            padding: 20px 10px;
            min-height: 450px;
        }
        
        .horizontal-arrow {
            color: #3498db;
            font-size: 24px;
            margin: 0 10px;
            display: flex;
            align-items: center;
        }
        
        .vertical-split {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 10px;
            min-width: 600px;
            position: relative;
        }
        
        .atom-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
        }
        
        .ion-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
            margin-left: 60px;
            position: relative;
            width: 260px;
        }
        
        .parallel-paths {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            width: 100%;
        }
        
        .cation-container {
            position: relative;
            right: 200px;
            z-index: 1;
        }
        
        /* Mobile adjustments for the flowchart */
        @media (max-width: 768px) {
            .main-flow {
                flex-direction: column;
                align-items: center;
                min-height: 900px;
                padding: 20px 0;
            }
            
            .horizontal-arrow {
                transform: rotate(90deg);
                margin: 10px 0;
            }
            
            .parallel-paths {
                flex-direction: column;
                gap: 20px;
                margin-top: 20px;
                margin-bottom: 20px;
            }
            
            .atom-column, .ion-column {
                gap: 20px;
            }
            
            .cation-container {
                right: 0;
                margin-bottom: 60px;
            }
            
            .vertical-split {
                min-width: 320px;
            }
            
            .sequence-area {
                min-height: 950px;
            }
        }
        
        /* Adjust for smaller screens */
        @media (max-width: 992px) {
            .vertical-split {
                min-width: 450px;
            }
            
            .drop-zone {
                width: 140px;
                height: 140px;
            }
            
            .cation-container {
                right: 150px;
            }
        }
        
        /* CSS changes for the grid layout */
        .flowchart-grid {
            display: grid;
            grid-template-columns: minmax(140px, 150px) minmax(70px, 90px) minmax(140px, 150px) minmax(70px, 90px) minmax(140px, 150px) minmax(70px, 90px) minmax(140px, 150px);
            grid-template-rows: minmax(160px, 180px) 40px minmax(160px, 180px);
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 0 auto;
            max-width: 100%;
            padding: 15px;
            background: linear-gradient(to right, rgba(240, 240, 240, 0.3), rgba(230, 245, 255, 0.5), rgba(240, 240, 240, 0.3));
            border-radius: 15px;
            min-width: max-content;
        }
        
        .arrow {
            font-size: 36px;
            color: #3498db;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            width: 100%;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
            position: relative;
        }
        
        .diagonal-up {
            transform: rotate(-5deg);
            font-size: 48px;
        }
        
        .diagonal-down {
            transform: rotate(5deg);
            font-size: 48px;
        }
        
        /* Replace text arrows with SVG */
        .arrow svg {
            width: 100%;
            height: 24px;
            stroke: #3498db;
            stroke-width: 3;
            fill: none;
        }
        
        .arrow svg polygon {
            fill: #3498db;
            stroke: #3498db;
        }
        
        .arrow.diagonal-up svg, 
        .arrow.diagonal-down svg {
            width: 90%;
            height: 90%;
        }
        
        /* Longer arrows for horizontal paths */
        .arrow[style*="grid-column: 4; grid-row: 1"] svg line,
        .arrow[style*="grid-column: 4; grid-row: 3"] svg line {
            stroke-width: 4;
        }
        
        /* Animation adjustments for SVG arrows */
        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.9; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0.9; }
        }
        
        .arrow:hover svg {
            animation: pulse 1.5s infinite;
        }
        
        .sequence-area {
            overflow-x: visible;
            min-height: 450px;
            padding: 15px;
            margin: 0 auto;
        }
        
        /* Styles for iframe embedding */
        @media (max-width: 1000px) {
            body {
                padding: 5px;
            }
            
            .sequence-area {
                padding: 10px;
                min-height: 500px;
            }
            
            .flowchart-grid {
                grid-template-columns: 130px 70px 130px 70px 130px 70px 130px;
                grid-template-rows: 150px 30px 150px;
                min-width: max-content;
                padding: 10px;
                gap: 8px;
            }
            
            .drop-zone {
                width: 120px;
                height: 120px;
            }
            
            .instructions {
                padding: 8px;
            }
            
            h1 {
                font-size: 1.4rem;
                margin: 8px 0;
            }
        }
        
        /* When embedded in iframe */
        @media (max-height: 700px) {
            h1 {
                font-size: 1.3rem;
                margin: 5px 0;
            }
            
            .instructions {
                padding: 8px;
                margin-bottom: 10px;
            }
            
            .instructions p {
                margin: 3px 0;
                font-size: 0.85rem;
            }
            
            .sequence-area {
                min-height: 420px;
            }
            
            .flowchart-grid {
                grid-template-rows: 140px 30px 140px;
                padding: 8px;
            }
            
            .drop-zone {
                width: 120px;
                height: 120px;
            }
            
            .button-container {
                margin-top: 10px;
            }
            
            button {
                padding: 8px 16px;
                font-size: 14px;
                margin: 0 5px 5px;
            }
        }
        
        /* Mobile adjustments for the flowchart */
        @media (max-width: 768px) {
            .flowchart-grid {
                grid-template-columns: 100px 60px 100px 60px 100px 60px 100px;
                grid-template-rows: 120px 30px 120px;
                gap: 8px;
                overflow-x: auto;
                min-width: max-content;
            }
            
            .drop-zone {
                width: 90px;
                height: 90px;
            }
            
            .arrow {
                font-size: 28px;
            }
            
            .diagonal-up, .diagonal-down {
                font-size: 36px;
            }
            
            .box-header {
                font-size: 14px;
                margin-bottom: 5px;
            }
            
            /* Add scrolling hint */
            .sequence-area::after {
                content: "← Scroll to see more →";
                display: block;
                text-align: center;
                padding: 5px;
                font-size: 12px;
                color: #777;
            }
        }
        
        @media (max-width: 600px) {
            .flowchart-grid {
                grid-template-columns: 75px 40px 75px 40px 75px 40px 75px;
                grid-template-rows: 100px 25px 100px;
                gap: 5px;
            }
            
            .drop-zone {
                width: 75px;
                height: 75px;
            }
            
            .arrow {
                font-size: 24px;
            }
            
            .diagonal-up, .diagonal-down {
                font-size: 30px;
            }
            
            .box-header {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <h1>Born-Haber Cycle - Part 1</h1>
    
    <div class="instructions">
        <p>In the Born-Haber Cycle, the formation of an ionic compound from its elements follows a specific pathway.</p>
        <p>Arrange the images in the correct sequence by dragging them into the boxes in the flowchart below. The process flows from left to right, with Elements splitting into parallel pathways before forming the final Ionic Compound.</p>
        <p>You'll need to determine which species belong in each unmarked position based on your understanding of the Born-Haber cycle. Click on two images to swap them, or click an image and then click on "Available Images" to return it. Click "Mark Answer" when you're done to check your sequence.</p>
    </div>
    
    <div class="container">
        <h3 class="source-heading">Available Images</h3>
        <div class="image-source" id="image-source">
            <div class="image-item" draggable="true" data-image="Gaseous anions.png" data-name="Gaseous anions">
                <img src="Gaseous anions.png" alt="Gaseous Anions">
            </div>
            <div class="image-item" draggable="true" data-image="Gaseous cations.png" data-name="Gaseous cations">
                <img src="Gaseous cations.png" alt="Gaseous cations">
            </div>
            <div class="image-item" draggable="true" data-image="Gaseous metal atoms.png" data-name="Gaseous metal atoms">
                <img src="Gaseous metal atoms.png" alt="Gaseous metal atoms">
            </div>
            <div class="image-item" draggable="true" data-image="Gaseous non-metal atoms.png" data-name="Gaseous non-metal atoms">
                <img src="Gaseous non-metal atoms.png" alt="Gaseous non-metal atoms">
            </div>
            <div class="image-item" draggable="true" data-image="Ionic compound.png" data-name="Ionic compound">
                <img src="Ionic compound.png" alt="Ionic compound">
            </div>
            <div class="image-item" draggable="true" data-image="Elements.png" data-name="Elements">
                <img src="Elements.png" alt="Elements">
            </div>
        </div>
        
        <div id="feedback"></div>
        
        <h3 class="sequence-heading">Arrange in Correct Sequence</h3>
        <div class="sequence-area">
            <div class="flowchart-grid" id="sequence-box">
                <!-- Elements (left column, spans both rows) -->
                <div class="drop-zone-container" style="grid-column: 1; grid-row: 1 / span 3; align-self: center;">
                    <div class="box-header">Elements</div>
                    <div class="drop-zone" data-position="1"></div>
                </div>
                
                <!-- Diagonal arrow going up -->
                <div class="arrow diagonal-up" style="grid-column: 2; grid-row: 1; align-self: end; padding-bottom: 0px; padding-right: 15px;">
                    ↗
                </div>
                
                <!-- Diagonal arrow going down -->
                <div class="arrow diagonal-down" style="grid-column: 2; grid-row: 3; align-self: start; padding-top: 20px; padding-right: 15px;">
                    ↘
                </div>
                
                <!-- Top atoms box -->
                <div class="drop-zone-container" style="grid-column: 3; grid-row: 1;">
                    <div class="drop-zone" data-position="2"></div>
                </div>
                
                <!-- Empty space for better layout -->
                <div style="grid-column: 3; grid-row: 2;"></div>
                
                <!-- Bottom atoms box -->
                <div class="drop-zone-container" style="grid-column: 3; grid-row: 3;">
                    <div class="drop-zone" data-position="3"></div>
                </div>
                
                <!-- Bottom horizontal arrow -->
                <div class="arrow" style="grid-column: 4; grid-row: 3;">
                    <svg viewBox="0 0 100 24">
                        <line x1="5" y1="12" x2="95" y2="12" />
                        <polygon points="95,12 85,7 85,17" />
                    </svg>
                </div>
                
                <!-- Bottom ions box -->
                <div class="drop-zone-container" style="grid-column: 5; grid-row: 3;">
                    <div class="drop-zone" data-position="5"></div>
                </div>
                
                <!-- Top horizontal arrow - only one arrow -->
                <div class="arrow" style="grid-column: 4; grid-row: 1; grid-column-end: 6;">
                    <svg viewBox="0 0 100 24">
                        <line x1="2" y1="12" x2="98" y2="12" />
                        <polygon points="98,12 88,7 88,17" />
                    </svg>
                </div>
                
                <!-- Top ions box (shifted left) -->
                <div class="drop-zone-container" style="grid-column: 6; grid-row: 1;">
                    <div class="drop-zone" data-position="4"></div>
                </div>
                
                <!-- Diagonal converging arrow from top (adjusted) -->
                <div class="arrow diagonal-down" style="grid-column: 7; grid-row: 1; align-self: end; padding-top: 20px; padding-left: 15px;">
                    ↘
                </div>
                
                <!-- Diagonal converging arrow from bottom (adjusted) -->
                <div class="arrow diagonal-up" style="grid-column: 7; grid-row: 3; align-self: start; padding-top: 0px; padding-left: 15px;">
                    ↗
                </div>
                
                <!-- Ionic compound (right column, spans both rows, adjusted) -->
                <div class="drop-zone-container" style="grid-column: 8; grid-row: 1 / span 3; align-self: center;">
                    <div class="box-header">Ionic Compound</div>
                    <div class="drop-zone" data-position="6"></div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="button-container">
        <button id="check-btn">Mark Answer</button>
        <button id="reset-btn">Reset</button>
    </div>
    
    <script>
        // Store the current sequence as the images are arranged
        let currentSequence = [null, null, null, null, null, null];
        
        document.addEventListener('DOMContentLoaded', function() {
            const imageItems = document.querySelectorAll('.image-item');
            const dropZones = document.querySelectorAll('.drop-zone');
            const imageSource = document.getElementById('image-source');
            const checkButton = document.getElementById('check-btn');
            const resetButton = document.getElementById('reset-btn');
            const feedbackDiv = document.getElementById('feedback');
            let selectedItem = null;
            let originalParent = null;
            
            // Set internal IDs for tracking purposes (not visible to users)
            let imageId = 1;
            imageItems.forEach(item => {
                item.dataset.id = imageId++;
            });
            
            // Set up drag and drop for the images
            imageItems.forEach(item => {
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('click', handleImageClick);
            });
            
            dropZones.forEach(zone => {
                zone.addEventListener('dragover', handleDragOver);
                zone.addEventListener('dragleave', handleDragLeave);
                zone.addEventListener('drop', handleDrop);
                zone.addEventListener('click', handleZoneClick);
            });
            
            // Add click handler to the image source container to return selected images
            imageSource.addEventListener('click', function(e) {
                // Only act if clicking directly on the container (not on an image)
                if (e.target === this && selectedItem) {
                    // Return the selected item to the image source
                    imageSource.appendChild(selectedItem);
                    selectedItem.classList.remove('selected');
                    
                    // Update the sequence array (find and remove the image from its position)
                    const imageId = selectedItem.dataset.id;
                    const position = currentSequence.indexOf(imageId);
                    if (position !== -1) {
                        // Find and update the drop zone
                        dropZones.forEach(zone => {
                            if (parseInt(zone.dataset.position) === position + 1) {
                                zone.classList.remove('filled');
                            }
                        });
                        
                        // Remove from sequence
                        currentSequence[position] = null;
                    }
                    
                    selectedItem = null;
                }
            });
            
            // Handle dragging start
            function handleDragStart(e) {
                originalParent = this.parentNode;
                setTimeout(() => {
                    this.style.display = 'none';
                }, 0);
                e.dataTransfer.setData('text/plain', this.dataset.id);
            }
            
            // Handle drag over drop zone
            function handleDragOver(e) {
                e.preventDefault();
                this.classList.add('active');
            }
            
            // Handle drag leaving drop zone
            function handleDragLeave() {
                this.classList.remove('active');
            }
            
            // Handle dropping the image
            function handleDrop(e) {
                e.preventDefault();
                this.classList.remove('active');
                const draggedItemId = e.dataTransfer.getData('text/plain');
                const draggedItem = document.querySelector(`[data-id="${draggedItemId}"]`);
                
                // If the drop zone already has an image, swap them
                const existingImage = this.querySelector('.image-item');
                if (existingImage) {
                    // Swap the items
                    originalParent.appendChild(existingImage);
                    existingImage.style.display = 'block';
                    
                    // If the original parent was a drop zone, update the sequence
                    if (originalParent.classList.contains('drop-zone')) {
                        const originalPosition = parseInt(originalParent.dataset.position) - 1;
                        currentSequence[originalPosition] = existingImage.dataset.id;
                    }
                }
                
                // Add the dragged item to this drop zone
                this.appendChild(draggedItem);
                draggedItem.style.display = 'block';
                this.classList.add('filled');
                
                // Update the sequence array
                const position = parseInt(this.dataset.position) - 1;
                currentSequence[position] = draggedItem.dataset.id;
            }
            
            // Click to select an image
            function handleImageClick(e) {
                // If this is a second click on the same item, deselect it
                if (selectedItem === this) {
                    selectedItem.classList.remove('selected');
                    selectedItem = null;
                    return;
                }
                
                // If there's already a selected item, handle swapping
                if (selectedItem) {
                    const firstItem = selectedItem;
                    const secondItem = this;
                    
                    // Get the parent elements
                    const firstParent = firstItem.parentNode;
                    const secondParent = secondItem.parentNode;
                    
                    // Remove selection styling
                    firstItem.classList.remove('selected');
                    
                    // If both parents are drop zones, swap the items and update sequence
                    if (firstParent.classList.contains('drop-zone') && secondParent.classList.contains('drop-zone')) {
                        // Swap the items
                        secondParent.appendChild(firstItem);
                        firstParent.appendChild(secondItem);
                        
                        // Update the sequence array
                        const firstPosition = parseInt(firstParent.dataset.position) - 1;
                        const secondPosition = parseInt(secondParent.dataset.position) - 1;
                        
                        currentSequence[firstPosition] = secondItem.dataset.id;
                        currentSequence[secondPosition] = firstItem.dataset.id;
                    } 
                    // If only the first item is in a drop zone, move it to image source and second to drop zone
                    else if (firstParent.classList.contains('drop-zone') && secondParent === imageSource) {
                        // Move first item to image source
                        imageSource.appendChild(firstItem);
                        
                        // Move second item to the drop zone
                        firstParent.appendChild(secondItem);
                        firstParent.classList.add('filled');
                        
                        // Update the sequence array
                        const dropPosition = parseInt(firstParent.dataset.position) - 1;
                        currentSequence[dropPosition] = secondItem.dataset.id;
                    }
                    // If only the second item is in a drop zone, move it to image source and first to drop zone
                    else if (secondParent.classList.contains('drop-zone') && firstParent === imageSource) {
                        // Move second item to image source
                        imageSource.appendChild(secondItem);
                        
                        // Move first item to the drop zone
                        secondParent.appendChild(firstItem);
                        secondParent.classList.add('filled');
                        
                        // Update the sequence array
                        const dropPosition = parseInt(secondParent.dataset.position) - 1;
                        currentSequence[dropPosition] = firstItem.dataset.id;
                    }
                    
                    selectedItem = null;
                    return;
                }
                
                // Select this item
                selectedItem = this;
                this.classList.add('selected');
            }
            
            // Click on a drop zone to place the selected image
            function handleZoneClick(e) {
                // Only respond to clicks directly on the zone, not on contained images
                if (e.target !== this) return;
                
                if (!selectedItem) return;
                
                // If the zone already contains an image, swap them
                const existingImage = this.querySelector('.image-item');
                if (existingImage) {
                    // Get the parent of the selected item
                    const selectedParent = selectedItem.parentNode;
                    
                    // If the selected item is from a drop zone, update that position in the sequence
                    if (selectedParent.classList.contains('drop-zone')) {
                        const selectedPosition = parseInt(selectedParent.dataset.position) - 1;
                        
                        // Move existing image to the selected item's former position
                        selectedParent.appendChild(existingImage);
                        
                        // Update sequence for the original position
                        currentSequence[selectedPosition] = existingImage.dataset.id;
                    } else {
                        // Just move the existing image to the source
                        imageSource.appendChild(existingImage);
                    }
                }
                
                // Place the selected image in this zone
                this.appendChild(selectedItem);
                this.classList.add('filled');
                selectedItem.classList.remove('selected');
                
                // Update the sequence array for the new position
                const position = parseInt(this.dataset.position) - 1;
                currentSequence[position] = selectedItem.dataset.id;
                
                selectedItem = null;
            }
            
            // Check the answer when the button is clicked
            checkButton.addEventListener('click', function() {
                // Check if all positions are filled
                if (currentSequence.includes(null)) {
                    showFeedback("Please fill all positions in the sequence.", false);
                    return;
                }
                
                // Get all the images in the sequence
                const sequenceImages = [];
                for (let i = 0; i < currentSequence.length; i++) {
                    const imageId = currentSequence[i];
                    const image = document.querySelector(`[data-id="${imageId}"]`);
                    sequenceImages.push(image);
                }
                
                // Check the sequence according to the specified rules order
                let isCorrect = true;
                let feedback = "";
                
                // Rule 1: Check if Elements is at the start
                if (sequenceImages[0].dataset.name !== "Elements") {
                    isCorrect = false;
                    feedback = "Elements should be at the start of the sequence as this is the initial state in the Born-Haber cycle.";
                }
                // Rule 2: Check if Ionic compound is at the end
                else if (sequenceImages[5].dataset.name !== "Ionic compound") {
                    isCorrect = false;
                    feedback = "Ionic compound should be at the end of the sequence as this is the final product of the Born-Haber cycle.";
                }
                // Rule 3: Check if ions come before atoms
                else if ((sequenceImages[1].dataset.name === "Gaseous anions" || sequenceImages[1].dataset.name === "Gaseous cations") ||
                         (sequenceImages[2].dataset.name === "Gaseous anions" || sequenceImages[2].dataset.name === "Gaseous cations")) {
                    isCorrect = false;
                    feedback = "Ions have to come after atoms in the reaction sequence. Atoms must be created first before they can gain or lose electrons.";
                }
                // Rule 4: Check if metal atoms go to the top row
                else if (sequenceImages[1].dataset.name === "Gaseous metal atoms") {
                    isCorrect = false;
                    feedback = "Think about which atom should be converted to ions first. Metal atoms should be placed in the bottom row because electrons have to be produced first.";
                }
                // Rule 5: Check if metal ions go above (after non-metal ions)
                else if (sequenceImages[3].dataset.name === "Gaseous cations" && sequenceImages[4].dataset.name === "Gaseous anions") {
                    isCorrect = false;
                    feedback = "Electrons have to be produced first. Metal atoms lose electrons to form cations, which must happen before non-metal atoms can gain electrons to form anions.";
                }
                // If all above rules pass, check the standard positions
                else if (sequenceImages[1].dataset.name !== "Gaseous non-metal atoms") {
                    isCorrect = false;
                    feedback = "The top position in the atoms column should contain gaseous non-metal atoms. Think about which atom should be converted to ions first.";
                }
                else if (sequenceImages[2].dataset.name !== "Gaseous metal atoms") {
                    isCorrect = false;
                    feedback = "The bottom position in the atoms column should contain gaseous metal atoms. Think about which atom should be converted to ions first.";
                }
                else if (sequenceImages[3].dataset.name !== "Gaseous anions") {
                    isCorrect = false;
                    feedback = "Gaseous anions should be in the top position of the ions column. Non-metal atoms gain electrons to form anions. Electrons have to be produced first before they can be taken in to form anions.";
                }
                else if (sequenceImages[4].dataset.name !== "Gaseous cations") {
                    isCorrect = false;
                    feedback = "Gaseous cations should be in the bottom position of the ions column. Metal atoms lose electrons to form cations. Electrons have to be produced first.";
                }
                
                // Display appropriate feedback
                if (isCorrect) {
                    showFeedback("Congratulations! Your sequence is correct.", true);
                } else {
                    showFeedback(feedback, false);
                }
            });
            
            // Reset the sequence
            resetButton.addEventListener('click', function() {
                // Move all images back to the source
                dropZones.forEach(zone => {
                    const image = zone.querySelector('.image-item');
                    if (image) {
                        imageSource.appendChild(image);
                        zone.classList.remove('filled');
                    }
                });
                
                // Reset the sequence array
                currentSequence = [null, null, null, null, null, null];
                
                // Deselect any selected item
                if (selectedItem) {
                    selectedItem.classList.remove('selected');
                    selectedItem = null;
                }
                
                // Hide feedback
                feedbackDiv.style.display = 'none';
            });
            
            // Display feedback to the user
            function showFeedback(message, isSuccess) {
                feedbackDiv.textContent = message;
                feedbackDiv.style.display = 'block';
                
                if (isSuccess) {
                    feedbackDiv.className = 'success';
                } else {
                    feedbackDiv.className = 'error';
                }
            }
        });
    </script>
</body>
</html>