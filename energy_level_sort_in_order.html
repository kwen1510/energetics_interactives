<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Drag and Drop Sorting</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #fdf6f0;
      margin: 0;
      padding: 20px;
      text-align: center;
      color: #333;
    }
    h2 {
      color: #555;
      margin-bottom: 10px;
    }
    .container {
      display: flex;
      justify-content: center;
      margin: 20px auto;
      gap: 30px; /* Increased gap between boxes */
    }
    .box, #items {
      width: 240px;
      min-height: 400px;
      border: 3px solid #a8dadc;
      background-color: #fff;
      border-radius: 10px;
      padding: 10px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      overflow-y: auto;
      word-wrap: break-word;
    }
    .box {
      /* Indicate drop zone with pointer cursor */
      cursor: pointer;
    }
    .box h3 {
      margin-top: 0;
      font-size: 20px;
      color: #457b9d;
    }
    .draggable {
      width: 90%;
      padding: 15px;
      margin: 5px auto;
      background-color: #a2d2ff;
      color: #1d3557;
      text-align: center;
      border-radius: 5px;
      cursor: grab;
      font-size: 16px;
      font-weight: bold;
      transition: transform 0.2s, box-shadow 0.2s;
      user-select: none;
    }
    .draggable:active {
      transform: scale(1.05);
      box-shadow: 0 5px 10px rgba(0,0,0,0.2);
    }
    /* Style for the selected element in click-drop mode */
    .selected {
      outline: 3px dashed #ffb4a2;
      background-color: #ffefef;
    }
    button {
      margin: 10px 5px;
      padding: 10px 20px;
      background-color: #b7e4c7;
      color: #1d3557;
      border: none;
      font-size: 16px;
      cursor: pointer;
      border-radius: 5px;
      transition: background-color 0.3s;
    }
    button:hover {
      background-color: #95d5b2;
    }
    #resetBtn {
      background-color: #ffc8dd;
    }
    #resetBtn:hover {
      background-color: #ffb3c6;
    }
    #feedback {
      margin-top: 15px;
      font-size: 18px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h2>Arrange the concepts from bottom to top</h2>
  <div class="container">
    <div class="box" id="sortableBox" ondragover="allowDrop(event)" onclick="clickDrop(event)">
      <h3>Sort Here</h3>
    </div>
    <div id="items">
      <div class="draggable" draggable="true" onclick="selectItem(event)" ondragstart="drag(event)" id="A">Atomisation</div>
      <div class="draggable" draggable="true" onclick="selectItem(event)" ondragstart="drag(event)" id="B">Ionisation Energy</div>
      <div class="draggable" draggable="true" onclick="selectItem(event)" ondragstart="drag(event)" id="C">Electron Affinity</div>
      <div class="draggable" draggable="true" onclick="selectItem(event)" ondragstart="drag(event)" id="D">Lattice Energy</div>
    </div>
  </div>
  <div>
    <button onclick="checkOrder()">Mark</button>
    <button id="resetBtn" onclick="resetItems()">Reset</button>
  </div>
  <p id="feedback"></p>

  <script>
    // Dynamic feedback rules.
    // For example, here the rule requires that "C" (Electron Affinity) must come before "B" (Ionisation Energy).
    const feedbackRules = [
      {
        if: "C",
        comes_before: "B",
        feedback: "Electron Affinity should come before Ionisation Energy because electrons need to be produced."
      },
      {
        if: "D",
        comes_before: "A",
        feedback: "You need to form the ions before using lattice energy."
      },
      {
        if: "D",
        comes_before: "B",
        feedback: "You need to form the ions before using lattice energy."
      },
      {
        if: "D",
        comes_before: "C",
        feedback: "You need to form the ions before using lattice energy."
      },
      {
        if: "C",
        comes_before: "A",
        feedback: "You need to form the gaseous atoms before performing Ea"
      },
      {
        if: "B",
        comes_before: "A",
        feedback: "You need to form the gaseous atoms before performing IE"
      }
      // Additional rules can be added here.
    ];

    let selectedElement = null; // For click-drop mode.

    function allowDrop(event) {
      event.preventDefault();
      // Change drop effect to provide visual feedback
      event.dataTransfer.dropEffect = "move";
    }

    function drag(event) {
      // Clear any selected element when a drag starts.
      clearSelection();
      event.dataTransfer.setData("text", event.target.id);
    }

    // Click handler for draggable items.
    function selectItem(event) {
      // Prevent triggering when the container is clicked.
      event.stopPropagation();
      // Toggle selection: if already selected, deselect it.
      if (selectedElement === event.currentTarget) {
        clearSelection();
      } else {
        clearSelection();
        selectedElement = event.currentTarget;
        selectedElement.classList.add("selected");
      }
    }

    // When clicking in the sortable box, drop the selected item.
    function clickDrop(event) {
      // Only act if there is a selected element.
      if (selectedElement) {
        const container = document.getElementById("sortableBox");
        // Compute the drop position based on the click Y coordinate.
        const afterElement = getDragAfterElement(container, event.clientY);
        if (afterElement == null) {
          container.appendChild(selectedElement);
        } else {
          container.insertBefore(selectedElement, afterElement);
        }
        clearSelection();
      }
    }

    // Clear the current selection.
    function clearSelection() {
      if (selectedElement) {
        selectedElement.classList.remove("selected");
        selectedElement = null;
      }
    }

    // Determines the drop position based on the mouse's Y coordinate.
    function getDragAfterElement(container, y) {
      const draggableElements = [...container.querySelectorAll('.draggable')];
      return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - (box.top + box.height / 2);
        if (offset < 0 && offset > closest.offset) {
          return { offset: offset, element: child };
        } else {
          return closest;
        }
      }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    function drop(event) {
      event.preventDefault();
      clearSelection();
      const data = event.dataTransfer.getData("text");
      const draggedElement = document.getElementById(data);
      const container = document.getElementById("sortableBox");
      const afterElement = getDragAfterElement(container, event.clientY);
      if (afterElement == null) {
        container.appendChild(draggedElement);
      } else {
        container.insertBefore(draggedElement, afterElement);
      }
    }

    function checkOrder() {
      // Get the current order of draggable items in the sortable box.
      const sortedItems = Array.from(document.getElementById("sortableBox").children)
                            .filter(el => el.classList.contains("draggable"))
                            .map(el => el.id);
      // The correct order is defined as top-to-bottom: D, C, B, A.
      const correctOrder = ["D", "C", "B", "A"];

      // If the order is exactly correct, display a success message.
      if (sortedItems.join() === correctOrder.join()) {
        document.getElementById("feedback").innerText = "Correct order! Well done!";
        document.getElementById("feedback").style.color = "green";
        return;
      }
      
      // Iterate through the dynamic feedback rules.
      for (let rule of feedbackRules) {
        const indexIf = sortedItems.indexOf(rule.if);
        const indexComesBefore = sortedItems.indexOf(rule.comes_before);
        // For a rule stating that X should come before Y, trigger an error if X is below Y.
        if (indexIf !== -1 && indexComesBefore !== -1 && indexIf > indexComesBefore) {
          document.getElementById("feedback").innerText = rule.feedback;
          document.getElementById("feedback").style.color = "red";
          return;
        }
      }

      // Fallback feedback if no specific rule applies.
      document.getElementById("feedback").innerText = "Incorrect order. Try again!";
      document.getElementById("feedback").style.color = "red";
    }

    function resetItems() {
      const itemsContainer = document.getElementById("items");
      // Reset the items back to the original container.
      const originalOrder = ["A", "B", "C", "D"];
      originalOrder.forEach(id => {
        const element = document.getElementById(id);
        itemsContainer.appendChild(element);
      });
      clearSelection();
      document.getElementById("feedback").innerText = "";
    }

    // Clear any selection if clicking outside a draggable.
    document.body.addEventListener("click", (event) => {
      if (!event.target.classList.contains("draggable")) {
        clearSelection();
      }
    });
  </script>
</body>
</html>
